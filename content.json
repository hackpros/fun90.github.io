{"meta":{"title":"Fun90","subtitle":"学习始于记录，贵在思考","description":"记录学习、开发、软件分享的地方，Java, Mac, 软件, 效率","author":"Fun90","url":"http://fun90.github.io"},"pages":[{"title":"MySQL数字类型区别与选择","date":"2014-02-15T14:07:36.000Z","updated":"2017-07-17T16:05:12.000Z","comments":true,"path":"MySQL数字类型区别与选择.html","permalink":"http://fun90.github.io/MySQL数字类型区别与选择.html","excerpt":"在开发中遇到需要替换JSON字符串某个key对应的双引号字符串，最后选择使用正则表达式来解决，接下来看看如何解决？","text":"在开发中遇到需要替换JSON字符串某个key对应的双引号字符串，最后选择使用正则表达式来解决，接下来看看如何解决？ 需求有JSON字符串：{&quot;code&quot;:&quot;kokf&quot;,&quot;params&quot;:&quot;{\\&quot;branchCode\\&quot;:\\&quot;yNeWWnKb\\&quot;,\\&quot;vendorCode\\&quot;:\\&quot;zvuXEixA\\&quot;}&quot;,&quot;timestamp&quot;:&quot;1499092515370&quot;}，需要匹配到params对应的值(包括引号)，即：“{\\”branchCode\\”:\\”yNeWWsMnKb\\”,\\”vendorCode\\”:\\”zvuXEiqtxA\\”}” 解决Java代码： 12Pattern paramsRegex = Pattern.compile(\"(\\\"params\\\"\\\\s*:\\\\s*)((?&lt;!\\\\\\\\)\\\".*?(?&lt;!\\\\\\\\)\\\")\");String sourceParams = matcher.group(2); // 匹配到params对应的参数内容 注意：在Java正则表达式中的反斜杠标识表示为\\\\，而在字符串中\\必须使用\\\\来表示，所以最后正则表达式的字符串为”\\\\\\\\” 延伸 断言类型 表达式 说明 零宽度负回顾后发断言 (?&lt;!exp) 匹配前面不是exp的位置 零宽度负预测先行断言 (?!exp) 匹配后面跟的不是exp的位置 零宽度正预测先行断言 (?=exp) 匹配exp前面的位置 零宽度正回顾后发断言 (?&lt;=exp) 匹配exp后面的位置 这里使用的是零宽度负回顾后发断言，(?&lt;!\\\\)&quot;匹配双引号『”』但是双引号『”』前面不是\\"},{"title":"About","date":"2017-07-14T08:30:40.000Z","updated":"2017-07-11T20:16:46.000Z","comments":true,"path":"about/index.html","permalink":"http://fun90.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-12-02T02:38:42.000Z","updated":"2017-07-17T16:14:53.000Z","comments":true,"path":"categories/index.html","permalink":"http://fun90.github.io/categories/index.html","excerpt":"","text":""},{"title":"Project","date":"2017-07-14T08:30:40.000Z","updated":"2017-07-11T20:16:46.000Z","comments":true,"path":"project/index.html","permalink":"http://fun90.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-07-14T08:30:40.000Z","updated":"2017-07-11T20:16:46.000Z","comments":true,"path":"tags/index.html","permalink":"http://fun90.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git-在新需求还未开发完时突然接到紧急修复任务怎么办","slug":"Git-在新需求还未开发完时突然接到紧急修复任务怎么办？","date":"2017-08-16T15:04:15.000Z","updated":"2017-08-20T15:20:21.000Z","comments":true,"path":"2017/08/16/git-stash/","link":"","permalink":"http://fun90.github.io/2017/08/16/git-stash/","excerpt":"关键字stash 储藏，保存当前的工作进度pull 从服务器更新代码push 将本地封存的修改推送到服务器commit 提交修改到本地git（注意与SVN不一样）","text":"关键字stash 储藏，保存当前的工作进度pull 从服务器更新代码push 将本地封存的修改推送到服务器commit 提交修改到本地git（注意与SVN不一样） 何谓储藏具体请看这篇文章《Git 工具 - 储藏（Stashing）》 不理解的话按我们开发过程中遇到的场景来讲一下 在新需求还未开发完时突然接到紧急修复任务我们在开发新需求（未开发完）时，突然有紧急bug要修复。此时，我们面临的问题有3个。 如何存放未完成的新需求代码？ 如何回到bug代码现场？ 如何在修复完bug后接着开发之前未完成的新需求？ 幸运的是Git解决这些问题快速且简单。大致只需3步： stash 储藏当前工作进度，取名为tmp（名字任意取，便于在恢复时区分）这时新需求的未完成代码已经储藏在了本地Git，并且工程目录下的代码恢复到了你上一次commit的状态，从现在开始修改代码不会影响新需求的代码。 修复bug并将代码push到服务器，在分支上跟我们平时开发提交代码一样，修复完bug测试通过后将代码push到服务。 恢复之前储藏的工作进度，继续开发未完成的新需求 注意事项Apply Stash之后，该Stash依旧留在本地列表中。若不再需要该Stash则需手动drop。你也可以勾选上 “Pop stash” 选项，勾选上后再Apply Stash则会在恢复完之后将这个Stash给Drop掉。这样可以避免本地Stash过多。drop时一定别删错了，否则将丢失修改的代码 当你在开发新需求和修复紧急bug修改了同一个文件，可能在恢复工作进度时会遇到冲突需要合并。 记住 除了第2步（修复bug并将代码push到服务器），其余步骤的操作均存于本地。 当你储藏工作进度的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。 stash不要存得过多，否则会连自己都搞不清楚存的那是些什么。 stash只是临时存放工作进度的一种快捷方法，如果新需求开发周期很长则需要新建分支。 分支看看分支是如何使用的：《Git 分支 - 何谓分支》、Git 分支 - 分支的新建与合并、Git 分支 - 利用分支进行开发的工作流程","categories":[{"name":"技术","slug":"tech","permalink":"http://fun90.github.io/categories/tech/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://fun90.github.io/tags/Git/"}]},{"title":"Maven打包插件：自动添加css js版本号","slug":"Maven打包自动添加css js版本号","date":"2017-07-24T14:46:18.000Z","updated":"2017-07-26T03:20:19.000Z","comments":true,"path":"2017/07/24/maven-package-plugin/","link":"","permalink":"http://fun90.github.io/2017/07/24/maven-package-plugin/","excerpt":"jcv-maven-plugin、maven-replacer-plugin这两款maven打包插件均可以实现在打出的包自动添加js/css版本号。jcv-maven-plugin是专门为压缩js/css文件和添加js/css版本号设计的一款插件，使用的人很少，使用说明文档较为模糊。maven-replacer-plugin则可以在打包时匹配指定文件中的内容并替换，这里介绍用来自动添加js/css版本号。","text":"jcv-maven-plugin、maven-replacer-plugin这两款maven打包插件均可以实现在打出的包自动添加js/css版本号。jcv-maven-plugin是专门为压缩js/css文件和添加js/css版本号设计的一款插件，使用的人很少，使用说明文档较为模糊。maven-replacer-plugin则可以在打包时匹配指定文件中的内容并替换，这里介绍用来自动添加js/css版本号。 jcv-maven-plugin介绍项目主页：https://github.com/byzy/jcv-maven-plugin jdk版本等注意事项、参数均在主页中有说明。 配置123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--将下列配置放在pom.xml的中--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;warSourceExcludes&gt;**/*.html,**/*.js,**/*.css&lt;/warSourceExcludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.iqarr.maven.plugin&lt;/groupId&gt; &lt;artifactId&gt;jcv-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;jsConstantName&gt;test&lt;/jsConstantName&gt; &lt;cssConstantName&gt;test&lt;/cssConstantName&gt; &lt;!--需要处理的文件后缀--&gt; &lt;suffixs&gt; &lt;param&gt;html&lt;/param&gt; &lt;/suffixs&gt; &lt;!--清理页面注释--&gt; &lt;clearPageComment&gt;true&lt;/clearPageComment&gt; &lt;!--压缩--&gt; &lt;compressionCss&gt;true&lt;/compressionCss&gt; &lt;compressionJs&gt;true&lt;/compressionJs&gt; &lt;globaJsMethod&gt;MD5_METHOD&lt;/globaJsMethod&gt; &lt;globaCssMethod&gt;MD5_METHOD&lt;/globaCssMethod&gt; &lt;versionLable&gt;v&lt;/versionLable&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 参数说明很模糊，在使用过程中看了参数说明文档仍不清楚有些关键参数的含义，最终打包也没达到预期的效果。不得不去查看插件源代码才搞清楚jsConstantName, cssConstantName这两个配置使用。 注意事项 prepare-package表示在真正打包之前，为准备打包执行任何必要的操作。这牵涉到maven build声明周期相关的配置，这里不做阐述，可查阅此处。 12345678&lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt;&lt;/executions&gt; 如果在页面引入js/css时把自定义的根目录写到了路径，例如：js文件路径为js/main.js(这路径是相对于工程目录webapp的)，根目录为/test，在页面中的路径被写为&lt;script src=&quot;/test/js/main.js&quot;&gt;&lt;/script&gt;，必须设置jsConstantName, cssConstantName的值为test，WARN：不要带斜杠/。 &lt;warSourceExcludes&gt;**/*.html,**/*.js,**/*.css&lt;/warSourceExcludes&gt;需要在maven-war-plugin中排除掉jcv-maven-plugin要处理的文件类型。 globaJsMethod, globaCssMethod推荐使用MD5_METHOD。 效果 maven-replacer-plugin介绍项目主页：https://code.google.com/archive/p/maven-replacer-plugin/ 配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;useCache&gt;true&lt;/useCache&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;prepare-war&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;exploded&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!--此插件用于获取当前时区当前时间--&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;timestamp-property&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;timestamp-property&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;name&gt;build.time&lt;/name&gt; &lt;pattern&gt;MdHHmmssSSS&lt;/pattern&gt; &lt;timeZone&gt;GMT+8&lt;/timeZone&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.google.code.maven-replacer-plugin&lt;/groupId&gt; &lt;artifactId&gt;replacer&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;replace&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;basedir&gt;$&#123;build.directory&#125;&lt;/basedir&gt; &lt;includes&gt; &lt;include&gt;$&#123;build.finalName&#125;/views/*.html&lt;/include&gt; &lt;/includes&gt; &lt;replacements&gt; &lt;replacement&gt; &lt;token&gt;\\.css\\\"&lt;/token&gt; &lt;value&gt;.css?v=$&#123;build.time&#125;\\\"&lt;/value&gt; &lt;/replacement&gt; &lt;replacement&gt; &lt;token&gt;\\.css\\'&lt;/token&gt; &lt;value&gt;.css?v=$&#123;build.time&#125;\\'&lt;/value&gt; &lt;/replacement&gt; &lt;replacement&gt; &lt;token&gt;\\.js\\\"&lt;/token&gt; &lt;value&gt;.js?v=$&#123;build.time&#125;\\\"&lt;/value&gt; &lt;/replacement&gt; &lt;replacement&gt; &lt;token&gt;\\.js\\'&lt;/token&gt; &lt;value&gt;.js?v=$&#123;build.time&#125;\\'&lt;/value&gt; &lt;/replacement&gt; &lt;/replacements&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 注意事项 &lt;useCache&gt;true&lt;/useCache&gt;，参见Stack Overflow 多文件引入使用&lt;basedir&gt;${build.directory}&lt;/basedir&gt;，参见Stack Overflow 通过变量${maven.build.timestamp}获取的时间不是当前时区，故引入插件build-helper-maven-plugin","categories":[{"name":"技术","slug":"tech","permalink":"http://fun90.github.io/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://fun90.github.io/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"http://fun90.github.io/tags/Maven/"}]},{"title":"Dubbo异常：forbid consumer","slug":"Dubbo异常：forbid consumer","date":"2016-06-14T13:56:17.000Z","updated":"2017-06-20T12:10:24.000Z","comments":true,"path":"2016/06/14/dubbo-forbid-whitelist/","link":"","permalink":"http://fun90.github.io/2016/06/14/dubbo-forbid-whitelist/","excerpt":"DUBBO 使用Dubbo开发过程中，经常会遇到forbid consumer whitelist/blacklist的错误.日志提示当前调用者被禁止访问某个服务，请检查下注册中心访问列表，还有黑名单和白名单。实际情况是我并根本没有对服务做白名单和黑名单机制.","text":"DUBBO 使用Dubbo开发过程中，经常会遇到forbid consumer whitelist/blacklist的错误.日志提示当前调用者被禁止访问某个服务，请检查下注册中心访问列表，还有黑名单和白名单。实际情况是我并根本没有对服务做白名单和黑名单机制.1com.alibaba.dubbo.rpc.RpcException: Forbid consumer 10.159.98.101 access service com.ai.ecs.order.api.OrderService from registry 10.154.73.105:2181 use dubbo version 2.5.3, Please check registry access list (whitelist/blacklist). 根据异常栈，抛出这个异常的代码在RegistryDirectory的第579行，如下：1234public List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123; if (forbidden ) &#123; throw new RpcException(RpcException.FORBIDDEN_EXCEPTION , ” Forbid consumer “ + NetUtils. getLocalHost() + ” access service “ + getInterface().getName() + ” from registry “ + getUrl().getAddress() + ” use dubbo version “ + Version.getVersion() + “, Please check registry access list (whitelist/blacklist).”); &#125; forbidden变量默认为false，那么什么时候变成true了呢？看RegistryDirectory的这段代码： private void refreshInvoker(List&lt;URL&gt; invokerUrls){ if (invokerUrls != null &amp;&amp; invokerUrls.size() == 1 &amp;&amp; invokerUrls.get(0) != null &amp;&amp; Constants.EMPTY_PROTOCOL .equals(invokerUrls.get(0).getProtocol())) { this.forbidden = true; // 禁止访问 this.methodInvokerMap = null; // 置空列表 destroyAllInvokers(); // 关闭所有Invoker } 如果invokerUrls的size为1，并且url的协议头是Constants.EMPTY_PROTOCOL时，则设置forbidden为true，Constants.EMPTY_PROTOCOL的值是empty。 refreshInvoker方法什么时候被调用呢？当某个服务的provider有变化时就会被调用，例如zookeeper上某个服务的provider目录里的内容发生变化，则zk监听器会被触发，由于provider的数量会发生变化，例如有一个新的provider启动了，有一个provider下线了，所以必须刷新本地的对provider的连接，具体逻辑就在refreshInvoker方法里。 当zookeeper初次订阅或者订阅的信息有变更时，都会触发toUrlsChanged方法，看看这个方法内部都做了什么，完整代码如下： private List&lt;URL&gt; toUrlsWithEmpty(URL consumer, String path, List&lt;String&gt; providers) { List&lt;URL&gt; urls = toUrlsWithoutEmpty(consumer, providers); if (urls == null || urls.isEmpty()) { int i = path.lastIndexOf('/'); String category = i &lt; 0 ? path : path.substring(i + 1); URL empty = consumer.setProtocol(Constants.EMPTY_PROTOCOL).addParameter(Constants.CATEGORY_KEY, category); urls.add(empty); } return urls; } 可见如果toUrlsWithoutEmpty的结果是空或者size为0，则强制返回一个protocol为empty的url，看来源头就在这里了。传入的List providers实际上就是最新的服务提供者信息，当某个服务没有任何provider时，providers就变为一个size为0的List了，导致返回一个协议头为empty的url，进而导致forbidden为true，屏蔽了consumer调用。","categories":[],"tags":[{"name":"DUBBO","slug":"DUBBO","permalink":"http://fun90.github.io/tags/DUBBO/"}]},{"title":"Spring事务","slug":"Spring事务","date":"2015-08-10T14:37:15.000Z","updated":"2017-07-26T03:20:19.000Z","comments":true,"path":"2015/08/10/spring-tx/","link":"","permalink":"http://fun90.github.io/2015/08/10/spring-tx/","excerpt":"事务传递","text":"事务传递 事务配置分为2类：拦截器、注解 拦截器12345678910111213141516171819202122232425262728293031&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置事务属性 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 定义查询方法只读 --&gt; &lt;tx:method name=\"query*\" read-only=\"true\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"get*\" read-only=\"true\"/&gt; &lt;!-- 主数据库操作 --&gt; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/&gt; &lt;!-- 其它方法使用默认事务策略 --&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置切面 --&gt;&lt;aop:config&gt; &lt;!-- 定义切面，所有的service的所有的方法 --&gt; &lt;aop:pointcut expression=\"execution(* com.test.spring.service.*.*(..))\" id=\"txPointcut\"/&gt; &lt;!-- 添加事务到切面上 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/&gt;&lt;/aop:config&gt; 注解123456&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 使事务注解生效 --&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 使用了Hibernate，class替换为org.springframework.orm.hibernate3.HibernateTransactionManager 1234@Transactional(propagation= Propagation.REQUIRED,rollbackFor=Exception.class,timeout=1,isolation= Isolation.DEFAULT) public void save(Map&lt;String, Object&gt; map) throws Exception &#123; &#125; 在要使用事务管理的类或者方法上增加代码@Transactional，Spring官方团队建议不要在接口使用。在类上使用@Transactional，类中的所有public方法都将使用事务。 在public方法上使用@Transactional，则该方法使用事务；非public方法使用@Transactional不会报错，但也不会使用事务，相当于“白做”。 事务传播 @Transactional(propagation=Propagation.REQUIRED)：默认的spring事务传播级别，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行，所以这个级别通常能满足处理大多数的业务场景。 @Transactional(propagation=PROPAGATION_SUPPORTS)：如果上下文存在事务，则支持当前事务，加入到事务执行，如果没有事务，则使用非事务的方式执行。所以说，并非所有的包在transactionTemplate.execute中的代码都会有事务支持。这个通常是用来处理那些并非原子性的非核心业务逻辑操作，应用场景较少。 @Transactional(propagation=PROPAGATION_MANDATORY)：该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。 @Transactional(propagation=PROPAGATION_REQUIRES_NEW)：每次都要一个新的事务，每次都会新建一个事务，并且同时将上下文中的事务挂起，当新建事务执行完成以后，上下文事务再恢复执行。 @Transactional(propagation=PROPAGATION_NOT_SUPPORTED)：当前级别的特点是,如果上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。这个级别有什么好处？可以帮助你将事务极可能的缩小。我们知道一个事务越大，它存在的风险也就越多，所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况。所以这个事务这个级别的传播级别就派上用场了，用当前级别的事务模板包起来就可以了。 @Transactional(propagation=PROPAGATION_NEVER)：一旦当前存在其他事务，就抛出runtime异常，强制停止执行！ @Transactional(propagation=PROPAGATION_NESTED)：如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。 数据库隔离级别 隔离级别 脏读（Dirty Read） 不可重复读（NonRepeatable Read） 幻读（Phantom Read） 未提交读（Read uncommitted） 可能 可能 可能 已提交读（Read committed） 不可能 可能 可能 可重复读（Repeatable read） 不可能 不可能 可能 可串行化（Serializable ） 不可能 不可能 不可能 名词 解释 脏读 一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这时候回滚了，那么第二个事务就读到了脏数据 不可重复读 一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进行了修改，这时候两次读取的数据是不一致的 幻读 第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一个事务就会丢失对新增数据的修改 数据库默认隔离级别 数据库 默认级别 MYSQL REPEATABLE_READ SQLSERVER READ_COMMITTED ORACLE READ_COMMITTED Spring事务隔离@Transactional(isolation = Isolation.隔离级别) 隔离级别 说明 DEFAULT 这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。 SERIALIZABLE 事务串行执行，资源消耗最大 REPEATABLE_READ 保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。 READ_COMMITTED 大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，该级别适用于大多数系统。 READ_UNCOMMITTED 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。 Spring事务回滚spring使用声明式事务处理，默认情况下，如果被注解的数据库操作方法中发生了unchecked异常，所有的数据库操作将rollback；如果发生的异常是checked异常，默认情况下数据库操作还是会提交的。 rollbackFor：该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如：指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)；指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class}) rollbackForClassName：该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如：指定单一异常类名称：@Transactional(rollbackForClassName=”RuntimeException”)；指定多个异常类名称：@Transactional(rollbackForClassName={“RuntimeException”,”Exception”}) noRollbackFor：该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。例如：指定单一异常类：@Transactional(noRollbackFor=RuntimeException.class)；指定多个异常类：@Transactional(noRollbackFor={RuntimeException.class, Exception.class}) noRollbackForClassName：该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。例如：指定单一异常类名称：@Transactional(noRollbackForClassName=”RuntimeException”)；指定多个异常类名：@Transactional(noRollbackForClassName={“RuntimeException”,”Exception”})","categories":[{"name":"技术","slug":"tech","permalink":"http://fun90.github.io/categories/tech/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://fun90.github.io/tags/Spring/"}]},{"title":"Java集合","slug":"Java集合","date":"2015-08-06T13:03:09.000Z","updated":"2017-07-14T09:19:38.000Z","comments":true,"path":"2015/08/06/java-collection/","link":"","permalink":"http://fun90.github.io/2015/08/06/java-collection/","excerpt":"总结了几张简单的图 Collection 图中的绿色的虚线代表实现，绿色实线代表接口之间的继承，蓝色实线代表类之间的继承。","text":"总结了几张简单的图 Collection 图中的绿色的虚线代表实现，绿色实线代表接口之间的继承，蓝色实线代表类之间的继承。 Map 区别","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fun90.github.io/tags/Java/"}]},{"title":"FastDFS安装笔记","slug":"FastDFS安装笔记","date":"2015-07-29T13:10:03.000Z","updated":"2017-06-20T06:51:56.000Z","comments":true,"path":"2015/07/29/fastdfs-install/","link":"","permalink":"http://fun90.github.io/2015/07/29/fastdfs-install/","excerpt":"版本说明 系统版本为CentOS 7 fastdfs版本选用的5.05 注意：系统版本不一样，相关命令会有差异 下载准备","text":"版本说明 系统版本为CentOS 7 fastdfs版本选用的5.05 注意：系统版本不一样，相关命令会有差异 下载准备选用fastdfsz的版本是5.05，区别于以往版本，这个版本将公共的一些函数等单独封装成了libfastcommon这个jar包，所以在安装fastdfs之前，我们必须先安装libfastcommon。 安装libfastcommon123456cd /optwget https://github.com/happyfish100/libfastcommon/archive/master.zipunzip master.zipcd libfastcommon-master./make.sh./make.sh install 缺少依赖包，出现如下错误： 安装依赖包1yum -y install gcc perl 再次安装libcofastcommon1cd ~/opt/libfastcommon-master &amp;&amp; ./make.sh &amp;&amp; ./make.sh install 安装fastdfs12345wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gztar -zxvf V5.05.tar.gz cd fastdfs-5.05/./make.sh./make.sh install 安装完成后，所有可执行文件在目录/usr/bin下，以fdfs_开头：12345678ls /usr/bin/fdfs_*/usr/bin/fdfs_appender_test /usr/bin/fdfs_monitor/usr/bin/fdfs_appender_test1 /usr/bin/fdfs_storaged/usr/bin/fdfs_append_file /usr/bin/fdfs_test/usr/bin/fdfs_crc32 /usr/bin/fdfs_test1/usr/bin/fdfs_delete_file /usr/bin/fdfs_trackerd/usr/bin/fdfs_download_file /usr/bin/fdfs_upload_appender/usr/bin/fdfs_file_info /usr/bin/fdfs_upload_file 配置文件在目录/etc/fdfs下：12ls /etc/fdfsclient.conf.sample storage.conf.sample tracker.conf.sample 配置Tracker跟踪器开放tracker监听端口访问12firewall-cmd --zone=public --add-port=22122/tcp --permanentfirewall-cmd --reload 修改Tracker配置文件1234mkdir -p /home/fastdfscd /etc/fdfscp tracker.conf.sample tracker.confsed -i 's:base_path=.*:base_path=/home/fastdfs:g' tracker.conf 设置Tracker便捷管理命令1234567891011121314bash -c 'cat &gt; /usr/lib/systemd/system/fdfs_trackerd.service &lt;&lt; EOF[Unit]Description=fastdfs tracker serverAfter=network.target[Service]Type=forkingPIDFile=/home/fastdfs/data/fdfs_trackerd.pidExecStart=/usr/bin/fdfs_trackerd /etc/fdfs/tracker.confExecReload=/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restartExecStop=/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop[Install]WantedBy=multi-user.targetEOF'systemctl enable fdfs_trackerd.service 启动tracker1systemctl start fdfs_trackerd.service 查看启动tracker日志，确认tracker是否启动成功1cat /home/fastdfs/logs/trackerd.log 配置Storage存储节点开放Storage监听端口访问12firewall-cmd --zone=public --add-port=23000/tcp --permanentfirewall-cmd --reload 修改Storage配置文件12345678mkdir -p /home/fastdfscd /etc/fdfscp storage.conf.sample storage.confcp /opt/fastdfs-5.05/conf/http.conf .cp /opt/fastdfs-5.05/conf/mime.types .sed -i 's:base_path=.*:base_path=/home/fastdfs:g' storage.confsed -i 's:store_path0=.*:store_path0=/home/fastdfs:g' storage.confsed -i 's/tracker_server=.*/tracker_server=192.168.0.80:22122/g' storage.conf 设置Storage便捷管理命令1234567891011121314bash -c 'cat &gt; /usr/lib/systemd/system/fdfs_storaged.service &lt;&lt; EOF[Unit]Description=fastdfs storage serverAfter=network.target[Service]Type=forkingPIDFile=/home/fastdfs/data/fdfs_storaged.pidExecStart=/usr/bin/fdfs_storaged /etc/fdfs/storage.confExecReload=/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restartExecStop=/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop[Install]WantedBy=multi-user.targetEOF'systemctl enable fdfs_storaged.service 启动Storage1systemctl start fdfs_storaged.service 查看启动Storage日志，确认Storage是否启动成功1cat /home/fastdfs/logs/storaged.log 配置Client客户端这里搭建的是测试环境，所以Client与Tracker、Storage都安装在同一台机器上12345mkdir -p /home/fastdfscd /etc/fdfscp client.conf.sample client.confsed -i 's:base_path=.*:base_path=/home/fastdfs:g' client.confsed -i 's/tracker_server=.*/tracker_server=192.168.0.80:22122/g' client.conf FastDFS测试上传测试1/usr/bin/fdfs_upload_file /etc/fdfs/client.conf /opt/Tulips.jpg 查看文件信息1/usr/bin/fdfs_file_info /etc/fdfs/client.conf group1/M00/00/00/wKgAUFXByOmAVJ5kAABzaUPC-FA256.jpg 下载测试1/usr/bin/fdfs_download_file /etc/fdfs/client.conf group1/M00/00/00/wKgAUFXByOmAVJ5kAABzaUPC-FA256.jpg downtest.jpg 重启命令12/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart Nginx安装安装缺少的依赖包1234yum install gcc-c++ yum install pcre pcre-devel yum install zlib zlib-devel yum install openssl openssl--devel 解压nginx-1.7.12.tar.gz，编译安装Nginx12345tar -zxvf nginx-1.7.12.tar.gzcd /opt/nginx-1.7.12./configure --prefix=/opt/nginx --user=nginx --group=nginx --with-pcre --with-debug --add-module=/opt/fastdfs-nginx-module-master/srcmakemake install 安装完最后会列出配置信息123456789101112131415161718Configuration summary + using PCRE library: /usr/lib64 + OpenSSL library is not used + using builtin md5 code + sha1 library is not found + using zlib library: /usr/lib64 nginx path prefix: \"/opt/nginx\" nginx binary file: \"/opt/nginx/sbin/nginx\" nginx configuration prefix: \"/opt/nginx/conf\" nginx configuration file: \"/opt/nginx/conf/nginx.conf\" nginx pid file: \"/opt/nginx/logs/nginx.pid\" nginx error log file: \"/opt/nginx/logs/error.log\" nginx http access log file: \"/opt/nginx/logs/access.log\" nginx http client request body temporary files: \"client_body_temp\" nginx http proxy temporary files: \"proxy_temp\" nginx http fastcgi temporary files: \"fastcgi_temp\" nginx http uwsgi temporary files: \"uwsgi_temp\" nginx http scgi temporary files: \"scgi_temp\" 防火墙开发HTTP服务12firewall-cmd --permanent --zone=public --add-service=httpfirewall-cmd --reload 创建nginx用户12useradd nginxpasswd 启动nginx1/opt/nginx/sbin/nginx 查看端口1netstat -tnlp|grep nginx 浏览器访问 其他命令Nginx -s stop 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。（quick exit）Nginx -s quit 平稳关闭Nginx，保存相关信息，有安排的结束web服务。（graceful exit）Nginx -s reload 因改变了Nginx相关配置，需要重新加载配置而重载。（changing configuration，start a new worker,quitting an old worker gracefully.)Nginx -s reopen 重新打开日志文件。(reopenging log files) fastdfs-nginx-module 配置1234cp /opt/fastdfs-nginx-module-master/src/mod_fastdfs.conf /etc/fdfs/touch /home/fastdfs/logs/mod_fastdfs.logchown nginx:nginx /home/fastdfs/logs/mod_fastdfs.logvi /etc/fdfs/mod_fastdfs.conf 修改1234base_path=/home/fastdfstracker_server=192.168.0.80:22122store_path0=/home/fastdfslog_filename=/home/fastdfs/logs/mod_fastdfs.log ##Storage服务器Nginx配置/usr/local/nginx/conf/nginx.conf 上server{} 里添加1234location ~/group1/M00 &#123; alias /home/fastdfs/data; ngx_fastdfs_module;&#125; Nginx重新加载配置1/opt/nginx/sbin/nginx -s reload 问题总结1、当上传文件时发现总是失败返回response status 2 !=0，查看storaged.log发现如下错误：用fdfs_monitor命令查看storage节点状态1/usr/bin/fdfs_monitor /etc/fdfs/storage.conf 发现两个离线状态的无效storage节点，用以下命令删除之1fdfs_monitor /etc/fdfs/client.conf delete group1 192.168.0.80 重启tracker及storage服务，问题解决。未深入分析原因。 2、访问图片出现400错误查看日志/home/fastdfs/logs/mod_fastdfs.log1[2015-07-30 16:24:13] ERROR - file: ../common/fdfs_global.c, line: 52, the format of filename &quot;group1/M00/00/00/wKgAUFW53n-AZ5X2AABzaUPC-FA370.jpg&quot; is invalid /opt/nginx/logs/error.log1192.168.0.170 - - [30/Jul/2015:16:13:06 +0800] &quot;GET /group1/M00/00/00/wKgAUFW5w4iAViuiAABVNkmGVeE577.xml HTTP/1.1&quot; 400 575 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.124 Safari/537.36&quot; 后查明是因为url中带了group名字，FastDFS是默认关闭的。1url_have_group_name=false 将以上参数改为true即可1sed 's:url_have_group_name.*:url_have_group_name=true:g' /etc/fdfs/mod_fastdfs.conf","categories":[],"tags":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://fun90.github.io/tags/FastDFS/"}]},{"title":"FastDFS资料整理","slug":"FastDFS资料整理","date":"2015-07-22T15:04:11.000Z","updated":"2017-06-20T06:53:37.000Z","comments":true,"path":"2015/07/22/fastdfs-info/","link":"","permalink":"http://fun90.github.io/2015/07/22/fastdfs-info/","excerpt":"需求至上，最近的，尽心费神，搭建图片服务器，研究了下分布式存储，最后选用了轻量级的fastdfs，刚接触使用难免会踩坑，整理些互联网上的资料都是大牛们的走过的路，这些资料能尽量避免少踩坑。 介绍最先看的是由FastDFS的作者happyfish100发表的分布式文件系统FastDFS架构剖析 原理篇大型网站图片服务器架构的演进 分布式文件系统FastDFS原理介绍","text":"需求至上，最近的，尽心费神，搭建图片服务器，研究了下分布式存储，最后选用了轻量级的fastdfs，刚接触使用难免会踩坑，整理些互联网上的资料都是大牛们的走过的路，这些资料能尽量避免少踩坑。 介绍最先看的是由FastDFS的作者happyfish100发表的分布式文件系统FastDFS架构剖析 原理篇大型网站图片服务器架构的演进 分布式文件系统FastDFS原理介绍 实践篇FastDFS使用经验分享 FastDFS问题集锦 FastDFS的配置、部署与API使用解读","categories":[],"tags":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://fun90.github.io/tags/FastDFS/"}]},{"title":"Java后台验证组件","slug":"Java后台验证组件","date":"2015-06-20T12:54:49.000Z","updated":"2016-01-14T02:57:59.000Z","comments":true,"path":"2015/06/20/fun-validation/","link":"","permalink":"http://fun90.github.io/2015/06/20/fun-validation/","excerpt":"在项目中前端和后端的验证都必不可少，公司使用的框架是基于Spring MVC开发，但未对验证做相应的解决方案，在网上找到了Validation.FO的验证框架，顿时被其简洁的设计所吸引，经过对其自定义的拓展开发，集成到了项目中。 Validation.FO 框架说明 这是一个验证框架，并且是一个 独立的验证框架 ，不依赖与其他已有的框架； 可以自由的嵌入到其他框架，比如Spring、Struts等流行框架，但实质来说他是独立的，所以无所谓嵌入到哪里，如果需要在GUI桌面应用中，也是完美的； 配置简单，可自由扩展验证器，实际只要实现IValidator接口，以及在rules.fo.xml中添加相关的配置即可； 支持Spring接口 使用过程中，你会感觉好像只用了 IValidateService.validate() 一个方法，这会让人感觉良好","text":"在项目中前端和后端的验证都必不可少，公司使用的框架是基于Spring MVC开发，但未对验证做相应的解决方案，在网上找到了Validation.FO的验证框架，顿时被其简洁的设计所吸引，经过对其自定义的拓展开发，集成到了项目中。 Validation.FO 框架说明 这是一个验证框架，并且是一个 独立的验证框架 ，不依赖与其他已有的框架； 可以自由的嵌入到其他框架，比如Spring、Struts等流行框架，但实质来说他是独立的，所以无所谓嵌入到哪里，如果需要在GUI桌面应用中，也是完美的； 配置简单，可自由扩展验证器，实际只要实现IValidator接口，以及在rules.fo.xml中添加相关的配置即可； 支持Spring接口 使用过程中，你会感觉好像只用了 IValidateService.validate() 一个方法，这会让人感觉良好 Validation.FO 相关资料Validation.FO 使用指南 Validation.FO 项目主页 配置繁多的缺点虽然Validation.FO这款验证框架有诸多的有点，但配置起来很是繁琐，基本没有可供公用的配置，而项目中很多地方的参数校验是通用的。 改进后的Fun.Validation基于Validation.FO修改后，虽然加入了引用和继承公用的配置，但这套设计是基于配置不可避免的仍然需要很多配置，目前尚未找到更好的设计方案。 Fun.Validation的项目主页","categories":[],"tags":[{"name":"Validation","slug":"Validation","permalink":"http://fun90.github.io/tags/Validation/"},{"name":"Java","slug":"Java","permalink":"http://fun90.github.io/tags/Java/"}]},{"title":"Java正则表达式匹配引号内容","slug":"Java正则表达式引号内容","date":"2014-02-10T15:36:27.000Z","updated":"2017-07-03T15:37:54.000Z","comments":true,"path":"2014/02/10/java-regex-double-quoted/","link":"","permalink":"http://fun90.github.io/2014/02/10/java-regex-double-quoted/","excerpt":"在开发中遇到需要替换JSON字符串某个key对应的双引号字符串，最后选择使用正则表达式来解决，接下来看看如何解决？","text":"在开发中遇到需要替换JSON字符串某个key对应的双引号字符串，最后选择使用正则表达式来解决，接下来看看如何解决？ 需求有JSON字符串：{&quot;code&quot;:&quot;kokf&quot;,&quot;params&quot;:&quot;{\\&quot;branchCode\\&quot;:\\&quot;yNeWWnKb\\&quot;,\\&quot;vendorCode\\&quot;:\\&quot;zvuXEixA\\&quot;}&quot;,&quot;timestamp&quot;:&quot;1499092515370&quot;}，需要匹配到params对应的值(包括引号)，即：“{\\”branchCode\\”:\\”yNeWWsMnKb\\”,\\”vendorCode\\”:\\”zvuXEiqtxA\\”}” 解决Java代码： 12Pattern paramsRegex = Pattern.compile(\"(\\\"params\\\"\\\\s*:\\\\s*)((?&lt;!\\\\\\\\)\\\".*?(?&lt;!\\\\\\\\)\\\")\");String sourceParams = matcher.group(2); // 匹配到params对应的参数内容 注意：在Java正则表达式中的反斜杠标识表示为\\\\，而在字符串中\\必须使用\\\\来表示，所以最后正则表达式的字符串为”\\\\\\\\” 延伸 断言类型 表达式 说明 零宽度负回顾后发断言 (?&lt;!exp) 匹配前面不是exp的位置 零宽度负预测先行断言 (?!exp) 匹配后面跟的不是exp的位置 零宽度正预测先行断言 (?=exp) 匹配exp前面的位置 零宽度正回顾后发断言 (?&lt;=exp) 匹配exp后面的位置 这里使用的是零宽度负回顾后发断言，(?&lt;!\\\\)&quot;匹配双引号『”』但是双引号『”』前面不是\\","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://fun90.github.io/tags/Java/"}]},{"title":"AJAX跨域POST问题(HTTP,HTTPS)","slug":"Ajax跨域问题(HTTP,HTTPS)","date":"2014-02-05T14:48:36.000Z","updated":"2017-07-14T09:20:48.000Z","comments":true,"path":"2014/02/05/xmlhttprequest-cros/","link":"","permalink":"http://fun90.github.io/2014/02/05/xmlhttprequest-cros/","excerpt":"浏览器遵循同源策略(same-origin policy)，它不允许当前站点的脚本与不同源的站点之间进行数据交互，只要协议、域名、端口有任何一个不同，都被视为不同源。但有时确实又必须在当前站点通过Ajax请求其他不同源的资源，这明显与同源策略相悖，于是就有了JavaScript跨域问题。 至于为什么要有同源策略，可以Google一下同源策略的详解，这里只记录如何解决Ajax跨域POst的问题，包括不同协议(HTTP, HTTPS)之间的Ajax请求。跨域问题的解决办法有很多，对于端口和协议的不同，只能通过后台来解决。 跨域资源共享(CORS)CORS原理CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了一种跨域访问的机制，当必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。","text":"浏览器遵循同源策略(same-origin policy)，它不允许当前站点的脚本与不同源的站点之间进行数据交互，只要协议、域名、端口有任何一个不同，都被视为不同源。但有时确实又必须在当前站点通过Ajax请求其他不同源的资源，这明显与同源策略相悖，于是就有了JavaScript跨域问题。 至于为什么要有同源策略，可以Google一下同源策略的详解，这里只记录如何解决Ajax跨域POst的问题，包括不同协议(HTTP, HTTPS)之间的Ajax请求。跨域问题的解决办法有很多，对于端口和协议的不同，只能通过后台来解决。 跨域资源共享(CORS)CORS原理CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了一种跨域访问的机制，当必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。 CORS实现通过CORS的机制可以让AJAX实现跨域访问，一个域上的网络应用向另一个域提交跨域AJAX请求，开发人员只需在接受请求的服务端新增响应头Access-Control-Allow-Origin即可，剩下的就交给浏览器与服务端去沟通了。 举个例子，浏览器打开的站点A.com给站点B.com发送AJAX请求，并得到B.com返回的数据进行处理，浏览器与B.com的服务端的交互过程如下： 在A.com的脚本发出跨域请求时，浏览器会先发出一个OPTIONS请求到B.com站点，用于查明这个跨域请求对于B.com站点是不是安全可接受的。 B.com后台服务端收到请求时： 如果响应头中新增了Access-Control-Allow-Origin来表明允许A.com的跨域请求，那么A.com的跨域AJAX请求可以正常执行下去。 否则，A.com的浏览器会报错：XMLHttpRequest cannot load http://B.com/api?p=a. No&#39;Access-Control-Allow-Origin&#39; header is present on the requested resource。 Origin &#39;A.com&#39; is therefore not allowed access. CORS浏览器支持情况 所遇问题 通过给XHR实例设置withCredentials属性的，必须为同源才可以。如：xhr.withCredentials = true 对于是POST和存在自定义HTTP头时无数据响应这两种情况可以通过添加Access-Control-Allow-Methods/Access-Control-Allow-Headers来解决。 对于多个站点域要跨域调用怎么办？搜了一下，有说通过空格分隔开Access-Control-Allow-Origin: http://a.com http://c.com，有说通过逗号分隔开的Access-Control-Allow-Origin: http://a.com, http://c.com，没有进行验证测试。(Access-Control-Allow-Origin: *)表示允许任何域都可以提交请求。 示例123response.setHeader(\"Access-Control-Allow-Origin\", \"http://A.com\");response.addHeader(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\");response.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With\");","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"http://fun90.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://fun90.github.io/tags/JavaScript/"}]},{"title":"MySQL获取汉字拼音首字母函数","slug":"MySQL获取汉字拼音首字母函数","date":"2014-01-25T13:49:05.000Z","updated":"2017-07-03T15:40:10.000Z","comments":true,"path":"2014/01/25/mysql-pinyin/","link":"","permalink":"http://fun90.github.io/2014/01/25/mysql-pinyin/","excerpt":"功能：支持多个汉字用法：SELECT PINYIN(‘单身不是狗’);+———————-+| PINYIN(‘单身不是狗’) |+———————-+| DSBSG |+———————-+1 row in set 注意：数据库的字符编码集得是UTF8或GBK才行。","text":"功能：支持多个汉字用法：SELECT PINYIN(‘单身不是狗’);+———————-+| PINYIN(‘单身不是狗’) |+———————-+| DSBSG |+———————-+1 row in set 注意：数据库的字符编码集得是UTF8或GBK才行。 第一步、创建表123456DROP TABLE IF EXISTS `pinyin`;CREATE TABLE `pinyin` ( `letter` char(1) NOT NULL, `chinese` char(1) NOT NULL, PRIMARY KEY (`letter`)) ENGINE=MyISAM DEFAULT CHARSET=gbk; 第二步、插入拼音数据123456789101112131415161718192021222324INSERT INTO `pinyin` VALUES('A','驁'),('B','簿'),('C','錯'),('D','鵽'),('E','樲'),('F','鰒'),('G','腂'),('H','夻'),('J','攈'),('K','穒'),('L','鱳'),('M','旀'),('N','桛'),('O','漚'),('P','曝'),('Q','囕'),('R','鶸'),('S','蜶'),('T','籜'),('W','鶩'),('X','鑂'),('Y','韻'),('Z','咗'); 第三步、创建函数1234567891011121314151617181920212223242526272829303132333435363738DELIMITER $$ DROP FUNCTION IF EXISTS `PINYIN`$$ CREATE FUNCTION `PINYIN`(str CHAR(255)) RETURNS char(255)BEGINDECLARE hexCode char(4);DECLARE pinyin varchar(255);DECLARE firstChar char(1);DECLARE aChar char(1);DECLARE pos int;DECLARE strLength int; SET pinyin = '';SET strLength = CHAR_LENGTH(LTRIM(RTRIM(str)));SET pos = 1;SET @str = (CONVERT(str USING gbk));WHILE pos &lt;= strLength DO SET @aChar = SUBSTRING(@str,pos,1); SET hexCode = HEX(@aChar); IF hexCode &gt;= \"8140\" AND hexCode &lt;= \"FEA0\" THEN SELECT letter into firstChar FROM pinyin WHERE chinese &gt;= @aChar LIMIT 1; ELSE SET firstChar = @aChar; END IF; SET pinyin = CONCAT(pinyin,firstChar); SET pos = pos + 1;END WHILE; RETURN UPPER(pinyin);END$$ DELIMITER ; 大功告成！","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://fun90.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"http://fun90.github.io/tags/DB/"}]},{"title":"编程高手的进阶之路","slug":"编程高手的进阶之路","date":"2014-01-15T15:18:46.000Z","updated":"2017-07-14T09:20:01.000Z","comments":true,"path":"2014/01/15/programming-genius/","link":"","permalink":"http://fun90.github.io/2014/01/15/programming-genius/","excerpt":"对于外界，Coding是被神化的，似乎需要极高的智商和热情才能从事这个行业。 IT界聪明的人很多，但极具天赋真正的能称之为天才的人不多，一般人们口中所谓的天才，只不过是比平常人更快的掌握技能、完成工作罢了；只要你找到了正确的方向，并辅以足够的时间，你一样能够踏上成功彼岸。 工作中解决问题的途径有很多，你能最快想到的方法一部分取决于你的天赋另一部分是靠经验。事实上，大部分人由于平时的工作繁重，不会去思考寻找最优的解决方案，写的代码能刚好满足需求就算完事了。这样无法得到提示你甚至会无形中加重自己的工作量，因为随着年龄的增长，属于你自己的时间会越来越少，你的精力会被生活瓜分。 如何才能得到最优秀的方案呢？ 首先，我们得知道什么才是最优秀的解决方案，最优解决方案需要你能够走在需求的前面，将当前需求里有的、没有直接提出来的、现在暂时没有但将来可能有的等等，及编程潜规则等各个方方面面都综合考虑，给出最优方案。以一招胜万招。 你不再被需求牵着走，而是你牵着需求走。注重细节，注意那些当前需求里没有明文给出的细节：代码性能的差异、运行平台（浏览器）的差异、需求的隐性扩展、代码的向后兼容等等。","text":"对于外界，Coding是被神化的，似乎需要极高的智商和热情才能从事这个行业。 IT界聪明的人很多，但极具天赋真正的能称之为天才的人不多，一般人们口中所谓的天才，只不过是比平常人更快的掌握技能、完成工作罢了；只要你找到了正确的方向，并辅以足够的时间，你一样能够踏上成功彼岸。 工作中解决问题的途径有很多，你能最快想到的方法一部分取决于你的天赋另一部分是靠经验。事实上，大部分人由于平时的工作繁重，不会去思考寻找最优的解决方案，写的代码能刚好满足需求就算完事了。这样无法得到提示你甚至会无形中加重自己的工作量，因为随着年龄的增长，属于你自己的时间会越来越少，你的精力会被生活瓜分。 如何才能得到最优秀的方案呢？ 首先，我们得知道什么才是最优秀的解决方案，最优解决方案需要你能够走在需求的前面，将当前需求里有的、没有直接提出来的、现在暂时没有但将来可能有的等等，及编程潜规则等各个方方面面都综合考虑，给出最优方案。以一招胜万招。 你不再被需求牵着走，而是你牵着需求走。注重细节，注意那些当前需求里没有明文给出的细节：代码性能的差异、运行平台（浏览器）的差异、需求的隐性扩展、代码的向后兼容等等。 搜索引擎是最好的老师打开搜索引擎，穷举所有的搜索结果。自己建立测试环境一一验证这些代码：去揣摩每段代码的意图，去比较每段代码之间的差异。这两条路可以让你快速完成原始积累，当你再面对大多数需求时能够说这些问题我以前做过，那你就水到渠成地晋阶了。 积累各种能够解决需求的方案，然后再验证每个方案，在这些方案中选择最好的一种。因此该阶段的进阶之路就是”行万里路，看万卷书”，积累各个需求的各个解决方案。 举个例子：删除一字符串中指定的字符。12345var str=\"www.baidu.com/?page=1\";str=str.replace('?page=1',\"\");alert(str);str=str.substring(0,str.indexof(\"/\"));alert(str); 首先不要苛责代码的对错严谨，毕竟每个程序员都有这样的一个过程；其次，这两段代码在这个实例里没有什么大过错，可能会有瑕疵，但能够解决问题（删除指定的字符），这就是这个级别的特征。 另外举个例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 计算系统当前是星期几var str = \"\";var week = new date().getday();if (week == 0) &#123; str = \"今天是星期日\";&#125; else if (week == 1) &#123; str = \"今天是星期一\";&#125; else if (week == 2) &#123; str = \"今天是星期二\";&#125; else if (week == 3) &#123; str = \"今天是星期三\";&#125; else if (week == 4) &#123; str = \"今天是星期四\";&#125; else if (week == 5) &#123; str = \"今天是星期五\";&#125; else if (week == 6) &#123; str = \"今天是星期六\";&#125;// 或者更好一些var str1 = \"今天是星期\";var week = new date().getday();switch (week) &#123; case 0 : str1 += \"日\"; break; case 1 : str1 += \"一\"; break; case 2 : str1 += \"二\"; break; case 3 : str1 += \"三\"; break; case 4 : str1 += \"四\"; break; case 5 : str1 += \"五\"; break; case 6 : str1 += \"六\"; break;&#125;alert(str);alert(str1); 能够正确地解决问题。不管你是通过搜索网络，或者通过改造某些成品代码（jquery/dojo/ext/yui）案例，只要能够无错地完成需求。 “字符串剪裁”代码进化版：123var str=&quot;www.baidu.com/?page=1&quot;;str=str.replace(/?page/,&quot;&quot;);alert(str); 说明：replace方法的第一个参数虽然可以支持字符串，但最佳的类型是正则表达式； “计算系统当前星期几”代码进化版：1234var a = new array(\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\");var week = new date().getday();var str = \"今天是星期\"+ a[week];alert(str); 说明：不管是从代码量、代码效率、代码优美性、代码思路来说，这个版本的这个日期处理代码都要优秀很多。 到了进化版，是不是最优秀的解决方案了呢？不一定，很多时候还需要根据实际情况来决定。 比如“字符串剪裁”的例子 ：1234567var str=\"www.baidu.com/?page=1\";// 1、字符串剪裁str.substring(0, str.indexof(\"?page=1\"));// 2、正则表达式str.replace(/?page=1/, \"\");// 3、字符串分拆、合并str.split(\"?page\").join(\"\"); 1、2、3有什么区别呢？从代码量来说”正则表达式”最优秀；从代码执行效率来说： “字符串剪裁”法最高（chrome中”正则表达式”效率最高），split法最次；从可扩展性上来说，”正则表达式”法最优。具体使用那种方案视具体的需求环境而定。 再比如“计算系统当前星期几”的例子是不是最优秀的代码呢？请看下面的实现方式：12// 计算系统当前是星期几var str = \"今天是星期\" + \"日一二三四五六\".charat(new date().getday()); 不要问我为什么，要成为优秀的程序员就是要这么倔强地追去完美。 通过一段时间的努力，很多人能够达到这个水平，但是，很大一部分人的编程能力也就止步于此。或限于产品的需求单一性，或限于需求开发的时间紧迫性，或限于人的惰性，能够完美地解决当前的需求就够了。 由于长期处于技术平台期，技术上得不到提高，通常这个级别的工程师会比较燥。技术上小有所成；或追求个人的突破；或追求产品差异性带来的新鲜感；或者只是想换个心情；因此很多此级别的工程师会经常换公司。 如何走在需求前面？“字符串剪裁”的例子已经很完美的解决了当前的问题，但如果有一天原始的url变成了“www.baidu.com/?size=10&amp;page=1”呢？所以当我们拿到“www.baidu.com/?page=1”的需求后，需要考虑很多没有直接提出来的、现在暂时没有但将来可能有的情况，如下面：123456789101112131415161718192021var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0// 我将这个字符串里所可能想到的各种情况都列举出来var a = [ \"http://www.xxx.com/vmpn=?pn=0\"// pn= 可能出现在 ? 前 , \"http://www.xxx.com/vmpn=?pn=\"// url里允许pn 值为空 , \"http://www.xxx.com/vmpn=?pn=0&amp;a=1\"// url 里可有多个字段 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0\"// 可能排在最后 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1\"// 可能有多个 pn 字段 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=2\"// 可能在中间 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;pn=1&amp;b=1\" // 可能在中间成组 , \"http://www.xxx.com/vmpn=?a=1&amp;pn=0&amp;b=1&amp;pn=1\" // 可能零星分布];/* 需求的不言之秘：? 若出现在字符串最尾则要去之? &amp; 两个符号不可重叠*/var reg = /((\\?)(pn=[^&amp;]*&amp;)+(?!pn=))|(((\\?|&amp;)pn=[^&amp;]*)+$)|(&amp;pn=[^&amp;]*)/g; for (var i = 0; i &lt; a.length; i++) &#123; alert(a + \"\\n\" + a.replace(reg, \"$2\"));&#125; 这里不再追求一招一式，对你来说不是使用什么创新绝招解决需求，而是给出成熟稳重的方案，从根上解决问题。针对某个当前需求你的代码可能不是最优，但是针对此类的需求你的代码却是最优秀的代码。 到了这一步单单依靠技巧和数量的累积已经没有什么效果了，建议在这个阶段末尾着重关注编程理论：面向对象/过程、代码组织形式、编译、代码规范、其它的框架设计等等1234567891011121314151617181920212223242526272829/*** 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰* @author: fun90* @version: 2012/12/16* @param &#123;string&#125; str 被正则表达式字符串保护编码的字符串* @return &#123;string&#125; 被保护处理过后的字符串*/function escapereg(str) &#123; return str.replace(new regexp(\"([.*+?^=!:\\x24&#123;&#125;()|[\\\\]\\/\\\\\\\\])\", \"g\"), \"\\\\\\x241\");&#125; /*** 删除url字符串中指定的 query* @author:fun90* @version:2012/12/16* @param &#123;string&#125; url url字符串* @param &#123;string&#125; key 被删除的query名* @return &#123;string&#125; 被删除指定 query 后的url字符串*/ function delurlquery(url, key) &#123; key = escapereg(key); var reg = new regexp(\"((\\\\?)(\"+ key +\"=[^&amp;]*&amp;)+(?!\"+ key + \"=))|(((\\\\?|&amp;)\"+ key +\"=[^&amp;]*)+$)|(&amp;\"+ key +\"=[^&amp;]*)\", \"g\"); return url.replace(reg, \"\\x241\")&#125;// 应用实例var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0delurlquery(str, \"pn\"); 这段代码与前一段代码从实现上来说没有太大的区别，但是从思路上来说却有着本质的区别：1、不再是就事论事，头疼医头，而是把一类问题抽象理论化，一招破万招；2、有封装的概念，不再是每次从零开始，而是站在半山腰开始爬。 现在可以多观察语言的组织结构，语言设计；看看原型链，链式语法编程，泛型，接口编程，dom遥控器等等；仔细阅读成熟的web前端开发框架的设计文档，看他们为什么要这样设计。 自成体系，化茧成蝶知道为什么这样设计，也知道什么样的设计最好。 123456789101112131415161718192021222324252627282930313233// 库文件 /util/string/escapereg.js/*** 在拼接正则表达式字符串时，消除原字符串中特殊字符对正则表达式的干扰* @author: fun90* @version: 2012/12/16* @param &#123;string&#125; str 被正则表达式字符串保护编码的字符串* @return &#123;string&#125; 被保护处理过后的字符串*/util.string.escapereg = function (str) &#123; return str.replace(new regexp(\"([.*+?^=!:\\x24&#123;&#125;()|[\\\\]\\/\\\\\\\\])\", \"g\"), \"\\\\\\x241\");&#125; // 库文件 /util/url/delquery.js/// include util.string.escapereg;/*** 删除url字符串中指定的 query* @author:meizz* @version:2010/12/16* @param &#123;string&#125; url url字符串* @param &#123;string&#125; key 被删除的query名* @return &#123;string&#125; 被删除指定 query 后的url字符串*/util.url.delquery = function (url, key) &#123; key = util.string.escapereg(key); var reg = new regexp(\"((\\\\?)(\"+ key +\"=[^&amp;]*&amp;)+(?!\"+ key + \"=))|(((\\\\?|&amp;)\"+ key +\"=[^&amp;]*)+$)|(&amp;\"+ key +\"=[^&amp;]*)\", \"g\"); return url.replace(reg, \"\\x241\")&#125; // 应用实例/// include util.url.delquery;var str = \"http://www.xxx.com/?pn=0\"; // 删除指定字符 pn=0util.url.delquery(str, \"pn\"); 经过不懈努力，经历思索磨砺，积累发散，成就辉煌。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"http://fun90.github.io/tags/Web/"},{"name":"Java","slug":"Java","permalink":"http://fun90.github.io/tags/Java/"}]},{"title":"Github同步代码","slug":"Github同步代码","date":"2014-01-12T14:12:43.000Z","updated":"2016-01-14T07:35:36.000Z","comments":true,"path":"2014/01/12/github-syn/","link":"","permalink":"http://fun90.github.io/2014/01/12/github-syn/","excerpt":"Git是个非常强大的源代码管理系统，能支持复杂的任务。似乎强大和复杂是一对孪生兄弟，Git的操作也不那么简单，让人有种手握重权却不知道怎么玩的尴尬，以及对自己智商的严重怀疑。下面是最基本的Git工作步骤，让我们找回一点点自信吧。 配置Git在本地尚未配置好Git的，请先查看如何配置Git 远程到本地全新克隆如果本地目录是从未使用的空目录（没有远程代码库的本地版本）","text":"Git是个非常强大的源代码管理系统，能支持复杂的任务。似乎强大和复杂是一对孪生兄弟，Git的操作也不那么简单，让人有种手握重权却不知道怎么玩的尴尬，以及对自己智商的严重怀疑。下面是最基本的Git工作步骤，让我们找回一点点自信吧。 配置Git在本地尚未配置好Git的，请先查看如何配置Git 远程到本地全新克隆如果本地目录是从未使用的空目录（没有远程代码库的本地版本） 先找到远程代码库的链接 在该文件夹下打开Git命令行，输入： 1git clone https://github.com/你的用户名/你的远程代码库名 更新代码本地目录有远程代码库的本地版本，想从远程代码库上取得最新版本，在本地目录（项目根目录）下打开Git命令行，输入：1git pull origin master 本地到远程第一步：加载文件修改的本地文件需要进行加载1git add . 其中“.”是将项目中所有修改过的文件和目录加载进去，如果只想加载特定的文件或目录，就将“.”换成文件或目录名1git add 文件或目录名 第二步：提交文件将第一步中加载过的文件提交到远程代码库，提交时必须附带有意义的注释。1git commit -m \"这里写提交的注释\" 第三步：推送文件第二步正常提交后，还需要我们发送命令行将代码推送到远程代码库 1、配置1git remote add origin https://github.com/你的用户名/你的远程代码库名 其中的origin是远程代码库的别名，可以使用其他任何你喜欢的词。甚至可以给本地代码配置多个远程代码库，只需要给他们取不同的别名。 2、推送1git push origin master 稍后你会被提示要求输入你的加密串，这个加密串跟在配置Git时输入的加密串，验证通过后本地代码库就会被推送到远程代码库中。","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"http://fun90.github.io/tags/Github/"}]},{"title":"Hexo简单笔记","slug":"Hexo简单笔记","date":"2014-01-11T01:19:06.000Z","updated":"2016-01-14T02:52:35.000Z","comments":true,"path":"2014/01/11/hexo-guide/","link":"","permalink":"http://fun90.github.io/2014/01/11/hexo-guide/","excerpt":"Hexo配置_config.yml 配置文件，respsitory配置为自己的仓库地址，注意type为git deploy: type: git repository: https://github.com/funxiong/fun90.github.io.git branch: master 修改文章访问地址: permalink: :year/:month/:day/:id/ source 博客数据源文件，其中的_post目录即是文章源文件(.md文件) themes 主题存放目录，推荐主题：Jacman(如何使用 Jacman 主题)","text":"Hexo配置_config.yml 配置文件，respsitory配置为自己的仓库地址，注意type为git deploy: type: git repository: https://github.com/funxiong/fun90.github.io.git branch: master 修改文章访问地址: permalink: :year/:month/:day/:id/ source 博客数据源文件，其中的_post目录即是文章源文件(.md文件) themes 主题存放目录，推荐主题：Jacman(如何使用 Jacman 主题) 新建文章执行new命令，生成指定名称的文章至hexo\\source_posts\\postName.md。、 hexo new &quot;postName&quot; 或者 在source_posts目录下新建.md的文件，文件内容： title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改 categories: #文章分类目录，可以为空，注意:后面有个空格 tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3] ---- 正文 生成页面执行generate命令，生成静态页面 hexo generate 或者简写 hexo g 预览执行server命令，浏览器输入http://localhost:4000 预览文章 hexo server 或者简写 hexo s 发布执行deploy命令，发布到Github服务器(注意把_config.yml的发布方式及地址配好) hexo deploy 或者简写 hexo d 相关教程Markdown语法教程","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"http://fun90.github.io/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://fun90.github.io/tags/Hexo/"}]},{"title":"Github搭建独立博客","slug":"Github搭建独立博客","date":"2014-01-10T05:39:36.000Z","updated":"2017-06-20T12:11:48.000Z","comments":true,"path":"2014/01/10/github-blog/","link":"","permalink":"http://fun90.github.io/2014/01/10/github-blog/","excerpt":"春眠不觉晓，处处问题不少。才疏学浅，资质愚钝，还不刻苦努力，荒废了人生，虚度了年华，从IT男变成了IT单身狗。在开发过程中遇到的问题，翻着墙用着Goolge搜索，忽然之间很多以github.io的博客如风雨过后菊花开般崛起。冒着好奇害死猫的风险开始探个究竟，果然入坑了。 准备 Git 下载 Node.js 下载 版本：Windows Installer (.msi) 忘了告诉你，这里是在Windows环境下的搭建，我的Mac一直在店里没去拿。","text":"春眠不觉晓，处处问题不少。才疏学浅，资质愚钝，还不刻苦努力，荒废了人生，虚度了年华，从IT男变成了IT单身狗。在开发过程中遇到的问题，翻着墙用着Goolge搜索，忽然之间很多以github.io的博客如风雨过后菊花开般崛起。冒着好奇害死猫的风险开始探个究竟，果然入坑了。 准备 Git 下载 Node.js 下载 版本：Windows Installer (.msi) 忘了告诉你，这里是在Windows环境下的搭建，我的Mac一直在店里没去拿。 安装软件 安装Git，按步骤默认安装就好，安装完后在开始菜单中会有Git的目录 同样安装好Node.js，安装完后在开始菜单中会有Node.js的目录 注册Github访问：https://www.github.com/ 注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。 创建仓库（repository）需要特别注意的就是Repository name，必须为username.github.io(useranem是指你的Github用户名)，不然不能被github解析。 配置Git在Windows下，开始菜单中找到Git目录打开Git Bash进入命令行界面。 检查SSH keys的设置首先我们需要检查你电脑上现有的ssh key： $ cd ~/.ssh 如果显示“No such file or directory”，跳过下一步，否则继续。 备份和移除原来的ssh key设置发现已经存在ssh key，在Git Bash中输入以下命令： $ ls $ config id_rsa id_rsa.pub known_hosts $ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa* 生成新的SSH Key输入以下命令： $ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; 命令行界面会出现： Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 这时回车就可以了，然后系统会要你输入加密串 Enter passphrase (empty for no passphrase):&lt;输入加密串&gt; Enter same passphrase again:&lt;再次输入加密串&gt; 最后看到这样的界面，就成功设置ssh key了： Your identifiaction has ban save in 省略一万字 在Windows下，进入系统盘的当前用户目录会看到.ssh目录，其中有一个叫id_rsa.pub的文件，如果看不到请设置显示隐藏文件。 添加SSH Key到GitHub 设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。 登陆GitHub，点击在主页右上角的头像的Setting，找到SSH keys进入。 点击Add SSH key，然后输入Title和Key的内容：Title是自定义，不重复即可；Key则是id_ras.pub用记事本打开，负责全部内容填入。 点击下方的Add key添加完成。 测试在添加完成后，输入以下命令： ssh -T git@github.com 如果是下面的反应： The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 输入yes并回车 Hi &lt;em&gt;username&lt;/em&gt;! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 说明已经成功的设置好了SSH Key。 设置账号信息现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是GitHub的用户名，而不是GitHub的昵称。 $ git config --global user.name &quot;你的名字&quot; $ git config --global user.email &quot;your_email@youremail.com&quot; OK，这样就可以使用Git将本地目录发布到Github的仓库中了。 安装HexoGithub的博客主页可以使用很多种模板系统，这里用的是Hexo，打开Git Bash命令行界面输入： npm install -g hexo 在Windows下建立hexo的目录，我将博客放在了D:/hexo 目录下，按住Shift见在新建的hexo目录上鼠标右击，点击Git Bash进入命令行界面输入： hexo init npm install 现在本地版本的hexo已经配置完成了，可以使用以下命令来生成静态文件： $ hexo g 这是生成静态页面的命令 $ hexo s 这是启动本地服务器的命令 然后打开浏览器输入 http://localhost:4000 即可看到hexo的主页。 点击查看Hexo简单笔记","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"http://fun90.github.io/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://fun90.github.io/tags/Hexo/"}]},{"title":"那些年，踩过的JavaScript之坑","slug":"那些年，踩过的JavaScript之坑","date":"2014-01-10T05:39:36.000Z","updated":"2017-07-03T15:42:26.000Z","comments":true,"path":"2014/01/10/javascript-pit/","link":"","permalink":"http://fun90.github.io/2014/01/10/javascript-pit/","excerpt":"你编，或者不编程，项目就在那里，还未完成。你调，或者不调试，BUG就在那里，早晚得改。你踩，或者不踩，坑都在那里，等下一个受害者。 变量作用域未使用var关键字定义的变量都是全局变量在JavaScript中定义变量时漏掉var并不会报错。 12345function foo() &#123; value = 100; // value前没有var关键字，则声明了全局变量value并赋了值&#125;foo();console.log(value); // 输出 100","text":"你编，或者不编程，项目就在那里，还未完成。你调，或者不调试，BUG就在那里，早晚得改。你踩，或者不踩，坑都在那里，等下一个受害者。 变量作用域未使用var关键字定义的变量都是全局变量在JavaScript中定义变量时漏掉var并不会报错。 12345function foo() &#123; value = 100; // value前没有var关键字，则声明了全局变量value并赋了值&#125;foo();console.log(value); // 输出 100 没有块作用域，只有函数作用域123456789function foo() &#123; for (var i = 0; i &lt; 10; i++) &#123; var value = \"hello world\"; &#125; console.log(i); // 输出 10 console.log(value); // 输出 hello world&#125;foo();console.log(value); // ReferenceError: value is not defined 上面的代码中可以看出，for循环外依然能访问变量i和value，但函数foo外面则无法访问。 如何优雅地绕过此坑： 在函数体的顶部声明可能用到的变量 函数体内不要使用同一名称命名不同意义的变量 变量的优先级下面的代码会让人觉得“匪夷所思”1234567var x = 1;function foo() &#123; console.log(x); //输出 undefined，而不是1 var x = 100; console.log(x); //输出 100&#125;foo(); WHY? JavaScript 是解释型语言，但它并不是直接逐步执行的，JavaScript解析过程分为先后两个阶段，一个是预处理阶段，另外一个就是执行阶段。在预处理阶段 JavaScript解释器将完成把JavaScript脚本代码转换到字节码，然后第二阶段JavaScript解释器借助执行环境把字节码生成机械 码，并顺序执行。 JavaScript的变量作用域是基于其特有的作用域链的，使用变量时JavaScript是按从下往上的顺序依次查找变量，没有找到就进入上一级直至全局变量。基于这一规则，函数体内部局部变量的优先级比同名的全局变量高。另外，函数中声明的变量在函数体内都可以使用，并可以重新赋值。 因此，上面的代码同于如下代码：12345678var x = 1;function foo() &#123; var x; console.log(x); //输出 undefined，而不是1 x = 100; console.log(x); //输出 100&#125;foo(); this的指向在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。 在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是： 有对象就指向调用对象 没调用对象就指向全局对象 用new构造就指向新对象 通过 apply 或 call 或 bind 来改变 this 的所指。 看下面的例子：12345678910111213141516171819202122232425262728var myObject = &#123; value: 100, getValue: function() &#123; var foo = function() &#123; console.log(this); // 没调用对象this指向全局对象 //console.log(this.value); // 输出 undefined &#125;; foo(); // 通过 apply 或 call 或 bind 来改变 this 的所指 foo.apply(myObject); // 输出 myObject foo.call(myObject); // 输出 myObject var newFoo = foo.bind(myObject); newFoo(); // 输出 myObject var SomeClass = function() &#123; this.value = 200; // 用new构造this指向新对象 &#125; var myCreate = new SomeClass(); console.log(myCreate.value); // 输出200 console.log(this); // this指向myObject return this.value; &#125;&#125;;console.log(myObject.getValue()); // 输出 100 闭包闭包是指有权限访问另一个函数作用域的变量的函数，创建闭包的常见方式就是在一个函数内部创建另一个函数。只要存在调用内部函数的可能，JavaScript就需要保留被引用的函数，而且JavaScript运行时需要跟踪引用这个内部函数的所有变量，直到最后一个变量废弃，JavaScript的垃圾收集器才能释放相应的内存空间。 12345678910111213&lt;button&gt;0&lt;/button&gt;&lt;button&gt;1&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;&lt;button&gt;3&lt;/button&gt;&lt;script&gt;var elements = document.getElementsByTagName('button');var n = elements.length;for (var i = 0; i &lt; n; i++) &#123; elements[i].onclick = function() &#123; console.log(\"This is element #\" + i); &#125;;&#125;&lt;/script&gt; 乍一看，上面的代码应该是点击不同按钮会输出不同的内容，但发现点击四个button都是输出“This is element # 4”，很奇怪，为什么？ 理一下执行过程： 当i的值为4的时，for循环执行完毕，但是因为每个button的onclick方法这时候为内部函数，所以i被闭包引用，内存不能被销毁，i的值会一直保持4，直到程序改变它或者所有的onclick函数销毁（主动把函数赋为null或者页面卸载）时才会被回收。这样每次我们点击button的时候，onclick函数会查找i的值（作用域链是引用方式），一查等于4，然后就输出了“This is element # 4”。 解决：123456789var elements = document.getElementsByTagName('button');var n = elements.length;for (var i = 0; i &lt; n; i++) &#123; (function(n) &#123; elements[i].onclick = function() &#123; console.log(\"This is element #\" + n); &#125; &#125;)(i);&#125; 第二种方式是使用了一个立即执行的函数又创建了一层闭包，函数声明放在括号内就变成了表达式，后面再加上括号括号就是调用了，这时候把i当参数传入，函数立即执行，num保存每次i的值(依次是0、1、2、3)，我们点击button的时候，就会得到我们想要的效果。 行尾的分号Javascript代码中分号是可选的，似乎很方便，但是很不幸的是经常会遇到因为漏掉了分号出现的错误，而解释器有时对这种错误定位不明确，必须由我们自己追溯并尝试去猜测因为哪些分号漏写导致的问题。 1234567891011121314function foo1() &#123; return &#123; key: \"value\" &#125;;&#125;console.log(foo1()); // 输出 &#123; key: 'value' &#125;function foo2() &#123; return &#123; a: \"hello\" &#125;;&#125;console.log(foo2()); // 输出 undefined foo2中分号自动加到了return语句后面，所以得到了“奇怪”的结果。 操作符双等号==操作符比较时会进行类型的强制转换，它可以比较两个不同类型的对象，在执行比较之前它将会尝试把这两个对象转换成同一个类型。 123console.log(\"\" == 0); //true - 空字符串会被强制转换为数字0. console.log(0 == \"0\"); //true - 数字0会被强制转换成字符串\"0\" console.log(\"\" == \"0\"); //false - 两操作数都是字符串所以不执行强制转换 如果使用三重等号（===），上面的三个比较都将返回false。 加减号12console.log(typeof (1 + \"1\"), 1 + \"1\"); // string 11 +号的操作数是数字与字符串，执行连接操作console.log(typeof (\"1\" - 1), \"1\" - 1); // number 0 相减操作会尝试将操作数转换成数字类型 数字类型浮点数运算看一个例子：1console.log(0.1 + 0.2 === 0.3); // false 惊天BUG？ JavaScript只有一种数字类型Number，没有Integer和Float，Number是IEEE标准中双精度浮点运算(64位)类型。 浮点数的精度问题不是JavaScript特有的，因为有些小数以二进制表示位数是无穷的，这就意味着JavaScript中浮点数运算会有无法避免的精度丢失。123console.log(0.1 + 0.2 === 0.3); // falseconsole.log(0.1 + 0.2); // 0.30000000000000004，精度丢失console.log(0.0 === 0); // true，integer和float没有区别 解决：在判断浮点运算结果前对计算结果进行精度缩小，因为在精度缩小的过程总会自动四舍五入:12var result = (0.1 + 0.2).toFixed(1);console.log(typeof result, result); // string 0.3，注意toFixed后的类型为string NaNNaN的类型是Number，NaN和任何东西比较都是false。12console.log(typeof NaN); // numberconsole.log(NaN === NaN); // fasle 还有很多坑没记上来，还有很多坑未踩过去 END！！！","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"http://fun90.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://fun90.github.io/tags/JavaScript/"}]}]}